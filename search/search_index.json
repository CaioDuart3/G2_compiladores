{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Apresenta\u00e7\u00e3o do projeto","text":"<p>Projeto de um compilador Python para C elaborado como parte da disciplina \"Compiladores\", ministrada pelo professor Sergio Freitas. O sistema \u00e9 desenvolvido pela equipe Runtime Terrors e tem como objetivo criar um compilador utilizando as ferramentas Flex e Bison.</p>"},{"location":"#estrutura-do-projeto","title":"Estrutura do Projeto","text":"<pre><code>\n\u251c\u2500\u2500 docs                  \n\u2502   \u251c\u2500\u2500 Desenvolvimento   \n\u2502   \u251c\u2500\u2500 Dificuldades      \n\u2502   \u251c\u2500\u2500 Escopo            \n\u2502   \u251c\u2500\u2500 Metodologia       \n\u2502   \u2514\u2500\u2500 Planejamento      \n\u251c\u2500\u2500 site                  \n\u251c\u2500\u2500 src                   \n\u2502   \u251c\u2500\u2500 lexer           \n\u2502   \u251c\u2500\u2500 parser            \n\u2502   \u251c\u2500\u2500 ast               \n\u2502   \u251c\u2500\u2500 st                \n\u2502   \u251c\u2500\u2500 tac               \n\u2502   \u251c\u2500\u2500 codigo_final     \n\u2502   \u2514\u2500\u2500 tests             \n\u251c\u2500\u2500 run_tests.sh          \n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 mkdocs.yml\n</code></pre>"},{"location":"#como-executar-o-projeto","title":"Como Executar o Projeto","text":""},{"location":"#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<p>Antes de iniciar, certifique-se de ter instalado:</p> <ul> <li>Python 3.8+</li> <li>Flex </li> <li>Bison </li> <li>GCC ou outro compilador C</li> <li>Make </li> </ul>"},{"location":"#instalacao-no-ubuntudebian","title":"Instala\u00e7\u00e3o no Ubuntu/Debian","text":"<pre><code>sudo apt update\nsudo apt install flex bison build-essential\n</code></pre>"},{"location":"#instalacao-no-macos","title":"Instala\u00e7\u00e3o no macOS","text":"<pre><code>brew install flex bison\n</code></pre>"},{"location":"#como-compilar-o-projeto","title":"Como Compilar o Projeto","text":"<p>Dentro da pasta <code>src/</code>:</p> <pre><code>cd src\nmake clean &amp;&amp; make\n</code></pre> <p>Isso ir\u00e1 gerar o bin\u00e1rio <code>compiler</code> dentro da pasta <code>src/</code>.</p>"},{"location":"#como-executar-o-compilador-python-para-c","title":"Como Executar o Compilador (Python para C)","text":"<p>Ap\u00f3s compilar o projeto, volte para a raiz do reposit\u00f3rio.</p> <ol> <li>Coloque seu arquivo Python na raiz</li> </ol> <p>Caso esteja em <code>src/</code> volte \u00e0 raiz com</p> <pre><code>cd ..\n</code></pre> <p>Insira o arquivo. Por exemplo: <code>seu_codigo.py</code></p> <p>Caso queira criar um novo arquivo, voc\u00ea pode usar o comando abaixo</p> <pre><code>touch seu_codigo.py\n</code></pre> <ol> <li>Torne o compilador execut\u00e1vel (somente na primeira execu\u00e7\u00e3o)</li> </ol> <pre><code>chmod +x compiler\n</code></pre> <ol> <li>Rodar o compilador</li> </ol> <p>Modo normal (gera o arquivo C, s\u00f3 mostra mensagens se der erro)</p> <pre><code>./compiler seu_codigo.py saida.c\n</code></pre> <p>Modo debug (mostra lexer, parser, AST, ST, TAC, etc.)</p> <pre><code>./compiler -d seu_codigo.py saida.c\n</code></pre> <ol> <li>Sa\u00edda gerada</li> </ol> <p>Se n\u00e3o houver erros, ser\u00e1 criado um arquivo C na raiz chamado <code>saida.c</code></p> <ul> <li> <p>Voc\u00ea pode trocar <code>saida.c</code> por outro nome de arquivo \u00e0 sua escolha.</p> </li> <li> <p>Em caso de erro</p> </li> <li> <p>O compilador n\u00e3o gera o arquivo .c</p> </li> <li>Uma mensagem detalhada de erro \u00e9 exibida no terminal</li> </ul>"},{"location":"#como-executar-os-testes","title":"Como Executar os Testes","text":"<p>Na pasta raiz do projeto: </p> <pre><code>chmod +x run_tests.sh &amp;&amp; ./run_tests.sh\n</code></pre> <p>O script ir\u00e1:</p> <ul> <li>Executar os arquivos de teste em <code>src/tests/inputs/</code></li> <li>Passar cada arquivo pelo compilador</li> <li>Gerar sa\u00eddas em <code>src/tests/outputs/</code></li> </ul>"},{"location":"#integrantes","title":"Integrantes","text":"Caio Duarte Isaque Camargos Laryssa Felix Ludmila Aysha Rafael Welz"},{"location":"#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"<p>Tabela 1: Hist\u00f3rico de vers\u00f5es</p> Vers\u00e3o Descri\u00e7\u00e3o Autor Data Revisor 1.0 Cria\u00e7\u00e3o do documento Caio Duarte 02/05/2025 Laryssa Felix 1.1 Atualiza\u00e7\u00e3o do documento Isaque Camargos 26/11/2025 Laryssa Felix 1.2 Insere como compilar c\u00f3digo Ludmila Aysha 27/11/2025 Caio Duarte <p>Fonte: Caio Duarte, Ludmila Aysha, Rafael Welz, Isaque Camargos, Laryssa Felix, 2025.</p>"},{"location":"Desenvolvimento/ast/","title":"AST - \u00c1rvore de Sintaxe Abstrata","text":""},{"location":"Desenvolvimento/ast/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>A \u00c1rvore de Sintaxe Abstrata (AST - Abstract Syntax Tree) \u00e9 a representa\u00e7\u00e3o intermedi\u00e1ria fundamental gerada pelo Analisador Sint\u00e1tico (Parser) ap\u00f3s a valida\u00e7\u00e3o da gram\u00e1tica do c\u00f3digo-fonte.</p> <p>Diferentemente da \u00e1rvore de an\u00e1lise sint\u00e1tica (parse tree), a AST \u00e9 uma representa\u00e7\u00e3o abstrata e simplificada da estrutura hier\u00e1rquica do c\u00f3digo. Ela elimina detalhes sint\u00e1ticos desnecess\u00e1rios (como par\u00eanteses, v\u00edrgulas e a chave de indenta\u00e7\u00e3o do Python) e ret\u00e9m apenas os elementos essenciais para a an\u00e1lise sem\u00e2ntica e a gera\u00e7\u00e3o de c\u00f3digo.</p> <p>A AST serve como a entrada principal para as fases posteriores do compilador, incluindo a An\u00e1lise Sem\u00e2ntica e a Gera\u00e7\u00e3o do C\u00f3digo Intermedi\u00e1rio (TAC).</p>"},{"location":"Desenvolvimento/ast/#2-metodologia","title":"2. Metodologia","text":"<p>A constru\u00e7\u00e3o da AST \u00e9 realizada pelas A\u00e7\u00f5es Sem\u00e2nticas integradas ao parser (Bison). Para cada regra gramatical reconhecida, fun\u00e7\u00f5es espec\u00edficas em <code>ast.c</code> s\u00e3o chamadas para alocar e conectar n\u00f3s, construindo a estrutura hier\u00e1rquica em mem\u00f3ria.</p>"},{"location":"Desenvolvimento/ast/#21-estrutura-de-dados-asth","title":"2.1. Estrutura de Dados (<code>ast.h</code>)","text":"<p>O n\u00f3 principal da AST \u00e9 a <code>struct NoAST</code>, que \u00e9 uma uni\u00e3o de dados que permite representar diversas constru\u00e7\u00f5es da linguagem em uma estrutura uniforme:</p> <ul> <li><code>TipoNo tipo</code> (Enumera\u00e7\u00e3o): Identifica o tipo de constru\u00e7\u00e3o sint\u00e1tica que o n\u00f3 representa (ex: <code>NO_NUM</code>, <code>NO_ATRIBUICAO</code>, <code>NO_FUNCAO</code>, <code>NO_WHILE</code>).</li> <li>Dados: Campos como <code>valor_int</code>, <code>valor_double</code>, <code>valor_string</code> e <code>operador</code> armazenam os valores literais e s\u00edmbolos dos n\u00f3s folha.</li> <li>Conex\u00f5es:<ul> <li>Filhos (<code>filho1</code>, <code>filho2</code>, <code>filho3</code>): Usados para representar a estrutura hier\u00e1rquica (ex: <code>filho1</code> \u00e9 a condi\u00e7\u00e3o, <code>filho2</code> \u00e9 o bloco THEN em um <code>NO_IF</code>).</li> <li>Pr\u00f3ximo (<code>proximo</code>): Usado para encadear n\u00f3s que pertencem \u00e0 mesma lista (ex: comandos em um bloco, argumentos em uma chamada de fun\u00e7\u00e3o).</li> </ul> </li> </ul>"},{"location":"Desenvolvimento/ast/#22-criacao-de-nos","title":"2.2. Cria\u00e7\u00e3o de N\u00f3s","text":"<p>A metodologia emprega fun\u00e7\u00f5es dedicadas para a cria\u00e7\u00e3o de cada tipo de n\u00f3, garantindo a inicializa\u00e7\u00e3o segura e a correta aloca\u00e7\u00e3o de mem\u00f3ria:</p> Fun\u00e7\u00e3o Exemplo Tipo de N\u00f3 Finalidade <code>criarNoNum(int valor)</code> <code>NO_NUM</code> Cria n\u00f3s para literais inteiros. <code>criarNoId(char *nome)</code> <code>NO_ID</code> Cria n\u00f3s para identificadores de vari\u00e1veis e fun\u00e7\u00f5es, alocando a string do nome. <code>criarNoOp(char op, NoAST *esq, NoAST *dir)</code> <code>NO_OP_BINARIA</code> Conecta os operandos (<code>esq</code> e <code>dir</code>) sob o n\u00f3 do operador. <code>criarNoListaComandos(...)</code> <code>NO_LISTA_COMANDOS</code> Constr\u00f3i blocos de c\u00f3digo (encadeamento de comandos com <code>proximo</code>). <code>criarNoChamadaFuncao(...)</code> <code>NO_CHAMADA_FUNCAO</code> Conecta o nome da fun\u00e7\u00e3o (<code>filho1</code>) \u00e0 lista de argumentos (<code>filho2</code>)."},{"location":"Desenvolvimento/ast/#3-papel-da-ast-no-compilador","title":"3. Papel da AST no Compilador","text":"<p>A AST \u00e9 o ponto central que conecta a fase de an\u00e1lise com as fases de processamento do c\u00f3digo.</p>"},{"location":"Desenvolvimento/ast/#31-analise-semantica-integrada","title":"3.1. An\u00e1lise Sem\u00e2ntica Integrada","text":"<p>Enquanto a AST \u00e9 constru\u00edda, o parser executa a\u00e7\u00f5es sem\u00e2nticas cr\u00edticas, utilizando a Tabela de S\u00edmbolos (<code>st.h</code>):</p> <ul> <li>Registro e Escopo: Vari\u00e1veis e fun\u00e7\u00f5es s\u00e3o registradas na tabela, e o controle de escopo (ex: em defini\u00e7\u00f5es de fun\u00e7\u00e3o) \u00e9 gerenciado.</li> <li>Infer\u00eancia de Tipos: A fun\u00e7\u00e3o <code>Tipo inferirTipo(NoAST *no)</code> percorre o n\u00f3 para determinar o tipo de dado resultante (necess\u00e1rio para a correta emiss\u00e3o de opcodes no TAC, como <code>TAC_SOMA</code> vs <code>TAC_SOMA_F</code>).</li> <li>Avalia\u00e7\u00e3o Constante: A fun\u00e7\u00e3o <code>int avaliarExpressao(NoAST *expr)</code> avalia express\u00f5es compostas apenas por literais e constantes conhecidas em tempo de compila\u00e7\u00e3o, otimizando o c\u00f3digo antes da gera\u00e7\u00e3o do TAC.</li> </ul>"},{"location":"Desenvolvimento/ast/#32-facilitacao-da-geracao-de-codigo","title":"3.2. Facilita\u00e7\u00e3o da Gera\u00e7\u00e3o de C\u00f3digo","text":"<p>O formato estruturado da AST simplifica o processo de Gera\u00e7\u00e3o de C\u00f3digo de Tr\u00eas Endere\u00e7os (TAC), permitindo que a fun\u00e7\u00e3o <code>processar_no</code> do TAC se concentre apenas na tradu\u00e7\u00e3o sequencial, sem se preocupar com a an\u00e1lise sint\u00e1tica.</p> <ul> <li>A estrutura hier\u00e1rquica (pais e filhos) da AST dita a ordem correta de avalia\u00e7\u00e3o das express\u00f5es, garantindo que as opera\u00e7\u00f5es sejam traduzidas na sequ\u00eancia l\u00f3gica.</li> </ul>"},{"location":"Desenvolvimento/ast/#4-implementacao","title":"4. Implementa\u00e7\u00e3o","text":""},{"location":"Desenvolvimento/ast/#41-codigo","title":"4.1. C\u00f3digo","text":"<p>O arquivo <code>ast.c</code> cont\u00e9m as fun\u00e7\u00f5es que gerenciam a aloca\u00e7\u00e3o, a constru\u00e7\u00e3o, a impress\u00e3o e a libera\u00e7\u00e3o da AST.</p>"},{"location":"Desenvolvimento/ast/#gerenciamento-e-debug","title":"Gerenciamento e Debug","text":"<ul> <li><code>imprimirAST(const NoAST *raiz, int indent)</code>: Fun\u00e7\u00e3o recursiva essencial para o debug, que percorre a \u00e1rvore e imprime a estrutura hier\u00e1rquica no console usando indenta\u00e7\u00e3o para visualizar o aninhamento.</li> <li><code>liberarAST(NoAST *raiz)</code>: Fun\u00e7\u00e3o recursiva que garante a desaloca\u00e7\u00e3o completa de todos os n\u00f3s da \u00e1rvore, incluindo as strings alocadas (ex: nomes de <code>NO_ID</code> e <code>NO_STRING</code>), prevenindo vazamentos de mem\u00f3ria.</li> </ul>"},{"location":"Desenvolvimento/ast/#funcoes-de-semantica-integrada","title":"Fun\u00e7\u00f5es de Sem\u00e2ntica Integrada","text":"<ul> <li><code>registrarParametros(NoAST *parametros)</code>: Percorre a lista de par\u00e2metros de uma fun\u00e7\u00e3o e os insere imediatamente na Tabela de S\u00edmbolos para o escopo atual, marcando-os como inicializados.</li> <li><code>executarAtribuicao(NoAST *no)</code>: Implementa a l\u00f3gica de tempo de execu\u00e7\u00e3o para atribui\u00e7\u00f5es, incluindo a manipula\u00e7\u00e3o de vetores indexados, e atualiza a Tabela de S\u00edmbolos com os valores e tipos.</li> </ul>"},{"location":"Desenvolvimento/ast/#5-execucao","title":"5. Execu\u00e7\u00e3o","text":""},{"location":"Desenvolvimento/ast/#51-codigo-fonte","title":"5.1. C\u00f3digo Fonte","text":"<p>O c\u00f3digo de teste utilizado (<code>ok_03_chamadaFuncao.py</code>) define duas vari\u00e1veis e duas fun\u00e7\u00f5es de soma, chamando a primeira fun\u00e7\u00e3o com vari\u00e1veis e a segunda com constantes:</p> <pre><code>a = 2\nb = 2\n\ndef soma(a, b):\n    return a + b\n\nprint(soma(a, b))\n\ndef soma2(c, d):\n    return c + d\n\nprint(soma(1, 2)) \n</code></pre> <p>Resultado da AST gerada pelo c\u00f3digo de teste mencionado:</p> <p></p>"},{"location":"Desenvolvimento/ast/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Vers\u00e3o Descri\u00e7\u00e3o Autor Data Revisor 1.0 Cria\u00e7\u00e3o do Documento Rafael Schadt 26/11/2025 Ludmila Nunes"},{"location":"Desenvolvimento/codigo_final/","title":"C\u00f3digo Final","text":""},{"location":"Desenvolvimento/codigo_final/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>Este documento descreve o funcionamento do m\u00f3dulo respons\u00e1vel por gerar o c\u00f3digo final em C. O objetivo dessa etapa \u00e9 transformar a representa\u00e7\u00e3o intermedi\u00e1ria do programa em um c\u00f3digo C, permitindo sua compila\u00e7\u00e3o e execu\u00e7\u00e3o.</p>"},{"location":"Desenvolvimento/codigo_final/#2-metodologia","title":"2. Metodologia","text":"<p>A implementa\u00e7\u00e3o segue uma abordagem sistem\u00e1tica baseada nos seguintes passos:</p> <ol> <li>Mapeamento da AST para C: Cada n\u00f3 da AST \u00e9 analisado para determinar o equivalente em c\u00f3digo C.</li> <li>Tratamento de comandos: Estruturas como atribui\u00e7\u00f5es, la\u00e7os, condi\u00e7\u00f5es, chamadas de fun\u00e7\u00e3o e retornos s\u00e3o traduzidas diretamente para sua sintaxe correspondente em C.</li> <li>Tradu\u00e7\u00e3o de tipos e operadores: Tipos primitivos e operadores da linguagem fonte s\u00e3o convertidos para seus equivalentes em C.</li> <li>Cria\u00e7\u00e3o de fun\u00e7\u00f5es e bloco principal: Fun\u00e7\u00f5es definidas pelo usu\u00e1rio s\u00e3o geradas antes do <code>main()</code>, e o bloco principal executa comandos globais e inicializa\u00e7\u00e3o de vetores.</li> <li>Integra\u00e7\u00e3o com tabela de s\u00edmbolos: A gera\u00e7\u00e3o de declara\u00e7\u00f5es utiliza informa\u00e7\u00f5es da tabela de s\u00edmbolos para mapear tipos corretos, valores iniciais e estruturas como vetores.</li> </ol>"},{"location":"Desenvolvimento/codigo_final/#3-papel-do-codigo-final-no-compilador","title":"3. Papel do C\u00f3digo Final no Compilador","text":"<p>O m\u00f3dulo analisado corresponde \u00e0 \u00faltima etapa do compilador. Seu papel inclui:</p> <ul> <li>Gerar c\u00f3digo C v\u00e1lido, leg\u00edvel e compil\u00e1vel.</li> <li>Trabalhar junto com o analisador sem\u00e2ntico e tabela de s\u00edmbolos.</li> <li>Aplicar sem\u00e2ntica operacional, por exemplo:</li> <li>Tradu\u00e7\u00e3o de <code>print()</code> para <code>printf()</code>;</li> <li>Expans\u00e3o de <code>for</code> usando <code>range()</code> em la\u00e7os <code>for</code> C;</li> <li>Mapeamento de listas e vetores.</li> </ul> <p>Sem essa etapa, o compilador n\u00e3o produziria sa\u00edda execut\u00e1vel.</p>"},{"location":"Desenvolvimento/codigo_final/#4-implementacao","title":"4. Implementa\u00e7\u00e3o","text":"<p>A implementa\u00e7\u00e3o cont\u00e9m os seguintes elementos principais:</p>"},{"location":"Desenvolvimento/codigo_final/#41-buffers-de-expressao","title":"4.1 Buffers de Express\u00e3o","text":"<p>Um pool circular evita aloca\u00e7\u00e3o din\u00e2mica repetida para express\u00f5es C.</p>"},{"location":"Desenvolvimento/codigo_final/#42-conversao-de-operadores","title":"4.2 Convers\u00e3o de Operadores","text":"<p>A fun\u00e7\u00e3o <code>operador_para_c()</code> traduz operadores aritm\u00e9ticos e l\u00f3gicos de Python para C.</p>"},{"location":"Desenvolvimento/codigo_final/#43-geracao-de-declaracoes","title":"4.3 Gera\u00e7\u00e3o de Declara\u00e7\u00f5es","text":"<p><code>gerar_declaracoes()</code> percorre a tabela de s\u00edmbolos gerando vari\u00e1veis globais com valores iniciais apropriados.</p>"},{"location":"Desenvolvimento/codigo_final/#44-geracao-de-expressoes","title":"4.4 Gera\u00e7\u00e3o de Express\u00f5es","text":"<p><code>gerar_expressao()</code> converte n\u00f3s da AST em representa\u00e7\u00f5es C: - n\u00fameros; - strings; - booleanos; - identificadores; - opera\u00e7\u00f5es bin\u00e1rias e l\u00f3gicas; - indexa\u00e7\u00e3o de vetores; - chamadas de fun\u00e7\u00e3o.</p>"},{"location":"Desenvolvimento/codigo_final/#45-geracao-de-comandos","title":"4.5 Gera\u00e7\u00e3o de Comandos","text":"<p><code>gerar_comando()</code> cobre: - atribui\u00e7\u00f5es; - atribui\u00e7\u00f5es m\u00faltiplas; - <code>if/else</code>; - <code>while</code>; - <code>for</code> com <code>range</code>; - retornos; - fun\u00e7\u00f5es.</p>"},{"location":"Desenvolvimento/codigo_final/#46-geracao-do-main","title":"4.6 Gera\u00e7\u00e3o do Main","text":"<p>O compilador inclui: - inicializa\u00e7\u00f5es de vetores; - comandos globais da AST; - retorno padr\u00e3o para terminar o programa.</p> <p>A fun\u00e7\u00e3o principal \u00e9 <code>gerar_codigo_final()</code>, que organiza todos os elementos gerados, inclui bibliotecas padr\u00e3o e monta o arquivo final em C.</p>"},{"location":"Desenvolvimento/codigo_final/#5-execucao","title":"5. Execu\u00e7\u00e3o","text":"<p>Para a execu\u00e7\u00e3o do c\u00f3digo final, na pasta raiz do projeto execute : </p> <pre><code>chmod +x run_tests.sh &amp;&amp; ./run_tests.sh\n</code></pre> <p>Procure por qualquer arquivo .cd dentro de src/tests/outputs/sintatico</p> <pre><code>cd src\ncd tests\ncd outputs\ncd sintatico\n</code></pre>"},{"location":"Desenvolvimento/codigo_final/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Vers\u00e3o Descri\u00e7\u00e3o Autor Data Revisor 1.1 Atualiza\u00e7\u00e3o do documento Isaque Camargos 26/11/2025 Rafael Welz"},{"location":"Desenvolvimento/lexer/","title":"Lexer - An\u00e1lise L\u00e9xica","text":""},{"location":"Desenvolvimento/lexer/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>O lexer (analisador l\u00e9xico) tem como objetivo ler o c\u00f3digo-fonte Python caractere por caractere e agrup\u00e1-los em sequ\u00eancias significativas chamadas tokens. Esses tokens representam as unidades at\u00f4micas (palavras-chave, identificadores, operadores, etc.) da linguagem e formam a entrada para a pr\u00f3xima fase: o analisador sint\u00e1tico (Parser).</p> <p>Este compilador implementa o l\u00e9xico de um subconjunto de Python, com foco, no momento, em:</p> <ul> <li>Tokens Essenciais: Palavras-chave, identificadores, literais (inteiros, floats, strings).</li> <li>Operadores Comuns: Aritm\u00e9ticos e de compara\u00e7\u00e3o.</li> <li>Delimitadores: Par\u00eanteses, v\u00edrgulas, dois-pontos, etc.</li> <li>Tratamento de Indenta\u00e7\u00e3o: Gera os tokens especiais <code>INDENT</code> e <code>DEDENT</code>, essenciais para a sintaxe Python.</li> </ul> <p>A ferramenta utilizada para a constru\u00e7\u00e3o do analisador l\u00e9xico \u00e9 o Flex (Fast Lexical Analyzer Generator).</p>"},{"location":"Desenvolvimento/lexer/#2-metodologia","title":"2. Metodologia","text":"<p>O desenvolvimento do lexer come\u00e7ou logo ap\u00f3s termos a estrutura base do parser definida, para garantir que ambos trabalhassem de forma integrada. A implementa\u00e7\u00e3o foi feita de maneira incremental:</p> <ul> <li>Primeiro foram criados os tokens fundamentais (identificadores, n\u00fameros, operadores simples).</li> <li>Em seguida, adicionamos palavras-chave, delimitadores e padr\u00f5es mais complexos, como floats e strings.</li> <li>Depois estruturamos o arquivo <code>lexer/lexer.l</code> com regex nomeadas para manter o c\u00f3digo mais limpo e organizado.</li> <li>O tratamento de indenta\u00e7\u00e3o foi incorporado cedo, j\u00e1 que a linguagem exige blocos definidos por recuo. Implementamos uma pilha de n\u00edveis e regras espec\u00edficas para gerar <code>INDENT</code> e <code>DEDENT</code>.</li> <li>Por fim, ajustamos as regras para ignorar coment\u00e1rios e espa\u00e7os irrelevantes e validamos tudo com testes simples para verificar o reconhecimento dos tokens e a detec\u00e7\u00e3o de erros.</li> </ul> <p>Essa abordagem permitiu que o lexer evolu\u00edsse junto do parser, garantindo compatibilidade e facilitando o avan\u00e7o das pr\u00f3ximas etapas do compilador.</p>"},{"location":"Desenvolvimento/lexer/#3-papel-do-lexer-no-compilador","title":"3. Papel do Lexer no Compilador","text":"<p>O pipeline geral do compilador \u00e9:</p> <p>C\u00f3digo Python -&gt; An\u00e1lise L\u00e9xica (Flex) -&gt; An\u00e1lise Sint\u00e1tica (Bison) -&gt; Representa\u00e7\u00e3o Intermedi\u00e1ria / AST -&gt; Gera\u00e7\u00e3o de C\u00f3digo C -&gt; C\u00f3digo C resultante</p> <p>A fun\u00e7\u00e3o do lexer \u00e9, portanto:</p> <ul> <li>Converter a sequ\u00eancia de caracteres do c\u00f3digo-fonte em uma sequ\u00eancia de tokens.</li> <li>Descartar elementos irrelevantes, como espa\u00e7os em branco (dentro das linhas) e coment\u00e1rios (<code>#</code>).</li> <li>Detectar e reportar caracteres inv\u00e1lidos.</li> <li>Gerenciar o estado de indenta\u00e7\u00e3o para produzir tokens de <code>INDENT</code> e <code>DEDENT</code>.</li> </ul>"},{"location":"Desenvolvimento/lexer/#4-implementacao","title":"4. Implementa\u00e7\u00e3o","text":""},{"location":"Desenvolvimento/lexer/#41-estrutura-do-arquivo-lexerl","title":"4.1. Estrutura do Arquivo lexer.l","text":"<p>O arquivo <code>lexer/lexer.l</code> \u00e9 dividido nas seguintes se\u00e7\u00f5es:</p>"},{"location":"Desenvolvimento/lexer/#411-secao-de-definicoes-em-c","title":"4.1.1. Se\u00e7\u00e3o de Defini\u00e7\u00f5es em C","text":"<p>Cont\u00e9m c\u00f3digo C necess\u00e1rio para o funcionamento do lexer e sua comunica\u00e7\u00e3o com o parser:</p> <ul> <li>Inclus\u00f5es: <code>stdio.h</code>, <code>string.h</code> e o arquivo gerado pelo Bison (<code>../parser/parser.tab.h</code>) para acessar as defini\u00e7\u00f5es dos tokens.</li> <li>Gerenciamento de Indenta\u00e7\u00e3o: Declara\u00e7\u00e3o da pilha <code>indent_stack</code> e das fun\u00e7\u00f5es auxiliares (<code>push_indent()</code>, <code>pop_indent()</code>, <code>top_indent()</code>) usadas para simular o comportamento de blocos do Python.</li> <li>Valor do Token: A vari\u00e1vel global <code>yytoken_value</code> \u00e9 usada para armazenar o lexema (o valor literal) de identificadores e literais.</li> </ul>"},{"location":"Desenvolvimento/lexer/#412-secao-de-definicoes-de-regex-e-regras","title":"4.1.2 Se\u00e7\u00e3o de Defini\u00e7\u00f5es de Regex e Regras","text":"<p>Esta se\u00e7\u00e3o define os padr\u00f5es (express\u00f5es regulares) e as a\u00e7\u00f5es correspondentes:</p> <ul> <li>Regex Nomeadas: Defini\u00e7\u00f5es como <code>DIGITO</code>, <code>LETRA</code> e <code>ID</code> s\u00e3o usadas para simplificar as regras.</li> <li>Prioridade das Regras: As palavras-chave (<code>\"if\"</code>, <code>\"else\"</code>, etc.) s\u00e3o listadas antes do padr\u00e3o gen\u00e9rico de identificador (<code>{ID}</code>) para garantir que sejam reconhecidas corretamente.</li> <li>A\u00e7\u00f5es: O c\u00f3digo C associado a um padr\u00e3o retorna o c\u00f3digo <code>TOKEN_*</code> correspondente ao parser.</li> </ul>"},{"location":"Desenvolvimento/lexer/#413-tratamento-da-indentacao","title":"4.1.3. Tratamento da Indenta\u00e7\u00e3o","text":"<p>O tratamento de indenta\u00e7\u00e3o \u00e9 realizado pela regra <code>^[ \\t]*</code> e pelo c\u00f3digo C nas a\u00e7\u00f5es:</p> <ol> <li>O padr\u00e3o casa com espa\u00e7os ou tabs apenas no in\u00edcio da linha.</li> <li>O comprimento do recuo (<code>yyleng</code>) \u00e9 comparado com o n\u00edvel atual (<code>top_indent()</code>).</li> <li>Se a indenta\u00e7\u00e3o aumentar, <code>TOKEN_INDENT</code> \u00e9 retornado.</li> <li>Se a indenta\u00e7\u00e3o diminuir, um ou mais <code>TOKEN_DEDENT</code> s\u00e3o retornados at\u00e9 que o n\u00edvel correto seja atingido.</li> </ol>"},{"location":"Desenvolvimento/lexer/#42-tokens-e-expressoes-regulares-implementadas","title":"4.2. Tokens e Express\u00f5es Regulares Implementadas","text":"<p>A tabela a seguir lista os principais padr\u00f5es de c\u00f3digo Python reconhecidos:</p> Padr\u00e3o (Regex/Literal) Token Gerado Descri\u00e7\u00e3o <code>\"if\"</code>, <code>\"else\"</code>, <code>\"while\"</code>, <code>\"for\"</code>, <code>\"def\"</code>, <code>\"return\"</code>, <code>\"in\"</code>, <code>\"True\"</code>, <code>\"False\"</code> <code>TOKEN_PALAVRA_CHAVE_*</code> Palavras-chave reservadas. <code>{ID}</code> <code>TOKEN_IDENTIFICADOR</code> Identificadores: nomes de vari\u00e1veis e fun\u00e7\u00f5es. <code>{DIGITO}+</code> <code>TOKEN_INTEIRO</code> N\u00fameros inteiros. <code>{DIGITO}+\\.({DIGITO}+)?([eE][+-]?{DIGITO}+)?</code> <code>TOKEN_FLOAT</code> N\u00fameros de ponto flutuante, com suporte a nota\u00e7\u00e3o cient\u00edfica. <code>\\\"[^\\\"]*\\\"</code>, <code>\\'[^\\']*\\'</code> <code>TOKEN_STRING</code> Strings literais comuns. <code>[fF]\"([^\"\\]                                                                                     | \\.)*\"</code>, <code>[fF]'([^'\\]             | \\.)*'</code> <code>TOKEN_STRING</code> F-strings (strings formatadas). <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> <code>TOKEN_OPERADOR_*</code> Operadores de compara\u00e7\u00e3o. <code>=</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> <code>TOKEN_OPERADOR_*</code> Operadores aritm\u00e9ticos e de atribui\u00e7\u00e3o. <code>\"and\"</code>, <code>\"or\"</code>, <code>\"not\"</code> <code>TOKEN_OPERADOR_LOGICO_*</code> Operadores l\u00f3gicos. <code>:</code>, <code>,</code>, <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code> <code>TOKEN_DELIMITADOR_*</code> S\u00edmbolos estruturais. <code>\\n</code> <code>TOKEN_NEWLINE</code> Quebra de linha. Indenta\u00e7\u00e3o no in\u00edcio da linha (conta espa\u00e7os/tabs) <code>TOKEN_INDENT</code> ou <code>TOKEN_DEDENT</code> Controle de blocos por indenta\u00e7\u00e3o. <code>[ \\t]+</code> (Ignorado) Espa\u00e7os e tabs dentro da linha. <code>#.*</code> (Ignorado) Coment\u00e1rios de linha. <code>.</code> <code>TOKEN_DESCONHECIDO</code> S\u00edmbolos inv\u00e1lidos."},{"location":"Desenvolvimento/lexer/#5-execucao","title":"5. Execu\u00e7\u00e3o","text":"<p>Ao executar uma an\u00e1lise l\u00e9xica , h\u00e1 dois resultados poss\u00edveis, dependendo se todos os caracteres da entrada formam tokens v\u00e1lidos segundo as regras definidas no arquivo lexer.l.</p>"},{"location":"Desenvolvimento/lexer/#51-caso-a-analise-lexica-seja-bem-sucedida","title":"5.1. Caso a an\u00e1lise l\u00e9xica seja bem-sucedida","text":"<p>Quando toda a entrada \u00e9 formada apenas por tokens v\u00e1lidos , o analisador l\u00e9xico processa corretamente cada lexema e imprime uma lista de tokens reconhecidos, um por linha, ou o formato definido no seu lexer_main.c.</p> <p>Exemplo de impressao em caso de  a an\u00e1lise l\u00e9xica seja bem-sucedida:</p> <pre><code>TOKEN_ID (variavel)\nTOKEN_NUM (123)\nTOKEN_OP_SOMA (+)\n</code></pre> <p>Esse resultado indica que:</p> <ul> <li> <p>Todos os caracteres foram lidos e convertidos corretamente em tokens;</p> </li> <li> <p>Nenhum lexema inv\u00e1lido foi encontrado;</p> </li> <li> <p>O fluxo da entrada est\u00e1 lexicalmente correto.</p> </li> </ul> <p>Nenhuma mensagem de erro \u00e9 exibida nesse caso, apenas a listagem dos tokens.</p>"},{"location":"Desenvolvimento/lexer/#52-caso-a-analise-lexica-encontre-erro","title":"5.2. Caso a an\u00e1lise l\u00e9xica encontre erro","text":"<p>Se a entrada contiver um caractere ou sequ\u00eancia que n\u00e3o corresponda a nenhum token definido , o analisador l\u00e9xico interrompeu o processamento e apresenta uma mensagem de erro</p> <pre><code>ERRO L\u00c9XICO (linha X): s\u00edmbolo inv\u00e1lido encontrado: @\n</code></pre> <p>Ap\u00f3s o erro, a an\u00e1lise \u00e9 encerrada imediatamente e a sa\u00edda do programa cont\u00e9m somente as mensagens at\u00e9 o ponto da falha.</p>"},{"location":"Desenvolvimento/lexer/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Vers\u00e3o Descri\u00e7\u00e3o Autor Data Revisor 1.0 Cria\u00e7\u00e3o da v1 da documenta\u00e7\u00e3o do lexer Rafael Schadt 01/10/2025 - 2.0 Atualiza\u00e7\u00e3o do documento Laryssa Felix 01/10/2025 Caio Duarte"},{"location":"Desenvolvimento/parser/","title":"Parser - An\u00e1lise Sint\u00e1tica","text":""},{"location":"Desenvolvimento/parser/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>O parser (analisador sint\u00e1tico) \u00e9 respons\u00e1vel por verificar se a sequ\u00eancia de tokens produzida pelo analisador l\u00e9xico segue as regras definidas pela gram\u00e1tica da linguagem-alvo, que, neste caso, \u00e9 um subconjunto de Python implementado para o compilador Python -&gt; C. Al\u00e9m de validar a estrutura sint\u00e1tica, o parser constr\u00f3i a base para a gera\u00e7\u00e3o da Abstract Syntax Tree (AST), que ser\u00e1 usada posteriormente na tradu\u00e7\u00e3o para c\u00f3digo C.</p> <p>Este compilador suporta:</p> <ul> <li>Atribui\u00e7\u00f5es (simples, m\u00faltiplas, encadeadas e indexadas);</li> <li>Express\u00f5es aritm\u00e9ticas e l\u00f3gicas;</li> <li>Chamadas de fun\u00e7\u00f5es;</li> <li>Listas e indexa\u00e7\u00f5es;</li> <li>Estruturas condicionais (<code>if</code>, <code>elif</code>, <code>else</code>);</li> <li>La\u00e7os (<code>while</code>, <code>for</code>);</li> <li>Declara\u00e7\u00f5es de fun\u00e7\u00e3o e instru\u00e7\u00f5es de retorno;</li> <li>Blocos estruturados por indenta\u00e7\u00e3o, assim como em Python.</li> </ul>"},{"location":"Desenvolvimento/parser/#2-metodologia","title":"2. Metodologia","text":"<p>O parser foi implementado utilizando Bison, seguindo o padr\u00e3o cl\u00e1ssico de compiladores baseados em gram\u00e1ticas livres de contexto. A metodologia adotada inclui:</p> <p>Integra\u00e7\u00e3o com o Analisador L\u00e9xico</p> <p>O parser consome tokens produzidos pelo Flex, incluindo informa\u00e7\u00f5es sobre valores e localiza\u00e7\u00e3o (<code>%locations</code>), permitindo melhor rastreamento de erros.</p> <p>Implementa\u00e7\u00e3o das Primeiras Regras</p> <p>A implementa\u00e7\u00e3o inicial do Parser concentrou-se nas regras gramaticais fundamentais, como express\u00f5es aritm\u00e9ticas, atribui\u00e7\u00f5es e chamadas de fun\u00e7\u00e3o. Essas primeiras defini\u00e7\u00f5es foram essenciais para que o grupo adquirisse dom\u00ednio sobre a ferramenta de gera\u00e7\u00e3o de analisadores e compreendesse, na pr\u00e1tica, como estruturar a gram\u00e1tica, integrar a\u00e7\u00f5es sem\u00e2nticas e lidar com potenciais conflitos de an\u00e1lise. Esse alicerce tornou poss\u00edvel, posteriormente, a expans\u00e3o da linguagem com constru\u00e7\u00f5es mais complexas e dependentes de escopo.</p> <p>Tratamento de Blocos com Indenta\u00e7\u00e3o</p> <p>A implementa\u00e7\u00e3o dos tokens <code>INDENT</code> e <code>DEDENT</code> foi fundamental para reproduzir o comportamento de blocos estruturais do Python, onde a delimita\u00e7\u00e3o de escopos depende exclusivamente da identa\u00e7\u00e3o. Essa etapa exigiu aten\u00e7\u00e3o especial do grupo, pois o tratamento correto desses tokens \u00e9 pr\u00e9-requisito para o funcionamento de estruturas como <code>if/else</code>, <code>for</code>, <code>while</code> e <code>def</code>.</p> <p>A complexidade surgiu principalmente da necessidade de sincronizar o analisador l\u00e9xico com o parser, garantindo que cada mudan\u00e7a no n\u00edvel de indenta\u00e7\u00e3o fosse refletida com precis\u00e3o na gram\u00e1tica. Esse mecanismo n\u00e3o apenas define os escopos corretamente, mas tamb\u00e9m permite a constru\u00e7\u00e3o consistente dos blocos na AST, evitando ambiguidades e garantindo que o compilador reconhe\u00e7a a hierarquia entre instru\u00e7\u00f5es.</p> <p>Uso de AST como Representa\u00e7\u00e3o Intermedi\u00e1ria</p> <p>O parser opera em integra\u00e7\u00e3o direta com o m\u00f3dulo de AST, construindo a \u00e1rvore sint\u00e1tica abstrata \u00e0 medida que cada regra gramatical \u00e9 reconhecida. Para cada produ\u00e7\u00e3o v\u00e1lida, a\u00e7\u00f5es sem\u00e2nticas espec\u00edficas criam e conectam n\u00f3s definidos em <code>ast.h</code>, garantindo que a estrutura sint\u00e1tica e sem\u00e2ntica do programa seja representada fielmente desde os primeiros est\u00e1gios da an\u00e1lise.</p> <p>Tabela de S\u00edmbolos</p> <p>Durante a an\u00e1lise, o parser utiliza e atualiza a Tabela de S\u00edmbolos (<code>st.h</code>) para:</p> <ul> <li>Registrar vari\u00e1veis e fun\u00e7\u00f5es;</li> <li>Verificar uso antes da defini\u00e7\u00e3o;</li> <li>Inferir tipos;</li> <li>Armazenar valores e tamanhos de vetores.</li> </ul> <p>A\u00e7\u00f5es sem\u00e2nticas integradas</p> <p>Al\u00e9m de construir a AST, o parser j\u00e1 resolve:</p> <ul> <li>Infer\u00eancia de tipos;</li> <li>Avalia\u00e7\u00e3o constante de express\u00f5es simples;</li> <li>Registro de par\u00e2metros de fun\u00e7\u00e3o;</li> <li>Verifica\u00e7\u00e3o de escopo com fun\u00e7\u00f5es como openScope() e closeScope().</li> </ul>"},{"location":"Desenvolvimento/parser/#3-papel-do-parser-no-compilador","title":"3. Papel do Parser no Compilador","text":"<p>O compilador segue o pipeline:</p> <p>C\u00f3digo Python -&gt; Lexer (Flex) -&gt; Parser (Bison) -&gt; AST/TAC -&gt; Gerador de C\u00f3digo Final -&gt; C\u00f3digo C</p> <p>O parser cumpre as seguintes fun\u00e7\u00f5es essenciais:</p> <p>Detec\u00e7\u00e3o de Erros Sint\u00e1ticos</p> <p>Mensagens detalhadas, indicando token problem\u00e1tico, linha e tipo de erro.</p> <p>Constru\u00e7\u00e3o da Estrutura Sint\u00e1tica</p> <p>Cada constru\u00e7\u00e3o Python \u00e9 convertida em um n\u00f3 sem\u00e2ntico representando elementos como:</p> <ul> <li>Atribui\u00e7\u00f5es;</li> <li>Condicionais;</li> <li>La\u00e7os;</li> <li>Chamada de fun\u00e7\u00f5es;</li> <li>Opera\u00e7\u00f5es aritm\u00e9ticas e l\u00f3gicas.</li> </ul> <p>Intera\u00e7\u00e3o com Demais M\u00f3dulos</p> <p>Durante a an\u00e1lise, o parser:</p> <ul> <li>Atualiza a Tabela de S\u00edmbolos;</li> <li>Constr\u00f3i a AST;</li> <li>Prepara dados para gera\u00e7\u00e3o de c\u00f3digo intermedi\u00e1rio (TAC) e final (C);</li> <li>Marca vari\u00e1veis como inicializadas ou vetores quando necess\u00e1rio.</li> </ul>"},{"location":"Desenvolvimento/parser/#4-implementacao","title":"4. Implementa\u00e7\u00e3o","text":"<p>A implementa\u00e7\u00e3o do parser est\u00e1 localizada em <code>parser/parser.y</code></p> <p>Ele \u00e9 dividido nas seguintes se\u00e7\u00f5es:</p>"},{"location":"Desenvolvimento/parser/#41-cabecalho-em-c","title":"4.1 Cabe\u00e7alho em C (<code>%{ ... %}</code>)","text":"<p>Inclui:</p> <ul> <li>Bibliotecas padr\u00e3o (<code>stdio.h</code>, <code>stdlib.h</code>, <code>string.h</code>);</li> <li>M\u00f3dulos internos do compilador:</li> <li>Tabela de S\u00edmbolos (<code>st.h</code>);</li> <li>AST (<code>ast.h</code>);</li> <li>C\u00f3digo Intermedi\u00e1rio (TAC) (<code>tac.h</code>);</li> <li>Gerador de c\u00f3digo final (<code>gerador_codigo_final.h</code>);</li> <li>Declara\u00e7\u00f5es de <code>yylex()</code> e <code>yyerror()</code>;</li> <li>Vari\u00e1vel global <code>raizAST</code>, que guarda a \u00e1rvore gerada.</li> </ul>"},{"location":"Desenvolvimento/parser/#42-definicoes-do-bison","title":"4.2 Defini\u00e7\u00f5es do Bison","text":"<p>Incluindo:</p> <ul> <li><code>%define parse.error verbose</code>: mensagens de erro detalhadas;</li> <li><code>%define parse.trace</code>: rastreamento opcional do parser;</li> <li><code>%locations</code>: suporte a linha/coluna;</li> </ul> <p>Defini\u00e7\u00e3o da union que armazena inteiros, floats, strings e ponteiros para n\u00f3s AST.</p>"},{"location":"Desenvolvimento/parser/#43-tokens","title":"4.3 Tokens","text":"<p>O parser reconhece:</p> <ul> <li>Identificadores, inteiros, floats, strings;</li> <li>Palavras-chave (<code>if</code>, <code>while</code>, <code>for</code>, <code>return</code>, <code>def</code>, etc.);</li> <li>Operadores aritm\u00e9ticos, l\u00f3gicos e relacionais;</li> <li>Delimitadores e s\u00edmbolos de estrutura;</li> <li>Tokens estruturais: <code>INDENT</code>, <code>DEDENT</code>, <code>NEWLINE</code>.</li> </ul>"},{"location":"Desenvolvimento/parser/#44-regras-de-precedencia","title":"4.4 Regras de Preced\u00eancia","text":"<p>Definidas para evitar ambiguidades, incluindo:</p> <ul> <li>Atribui\u00e7\u00f5es (right associative);</li> <li>Operadores l\u00f3gicos (<code>and</code>, <code>or</code>, <code>not</code>);</li> <li>Compara\u00e7\u00f5es;</li> <li>Operadores aritm\u00e9ticos.</li> </ul>"},{"location":"Desenvolvimento/parser/#45-gramatica","title":"4.5 Gram\u00e1tica","text":"<p>Cobre:</p> <ul> <li>Programa com lista de comandos;</li> <li>Blocos indentados;</li> <li><code>if</code> / <code>elif</code> / <code>else</code>;</li> <li>La\u00e7os <code>while</code> e <code>for</code>;</li> <li>Atribui\u00e7\u00f5es (simples, m\u00faltipla, encadeada, indexada);</li> <li>Chamadas de fun\u00e7\u00e3o;</li> <li>Declara\u00e7\u00e3o de fun\u00e7\u00f5es com par\u00e2metros;</li> <li>Retorno de fun\u00e7\u00e3o;</li> <li>Express\u00f5es aritm\u00e9ticas, l\u00f3gicas e relacionais;</li> <li>Literais: inteiros, floats, booleanos, strings, listas;</li> <li>Indexa\u00e7\u00f5es.</li> </ul> <p>A\u00e7\u00f5es sem\u00e2nticas constroem n\u00f3s AST com fun\u00e7\u00f5es como:</p> <ul> <li><code>criarNoAtribuicao</code></li> <li><code>criarNoOp</code></li> <li><code>criarNoBool</code></li> <li><code>criarNoChamadaFuncao</code></li> <li><code>criarNoLista</code></li> <li><code>criarNoIndex</code></li> </ul> <p>Entre outras</p>"},{"location":"Desenvolvimento/parser/#46-integracao-com-tabela-de-simbolos","title":"4.6 Integra\u00e7\u00e3o com Tabela de S\u00edmbolos","text":"<p>Em regras como atribui\u00e7\u00e3o simples:</p> <ul> <li>A vari\u00e1vel \u00e9 registrada caso ainda n\u00e3o exista;</li> <li>Tipo \u00e9 inferido a partir da express\u00e3o;</li> <li>Valores s\u00e3o avaliados para constantes;</li> <li>Vetores t\u00eam tamanho inferido automaticamente.</li> </ul>"},{"location":"Desenvolvimento/parser/#47-tratamento-de-erros","title":"4.7 Tratamento de Erros","text":"<p><code>yyerror()</code> gera mensagens como:</p> <pre><code>ERRO (linha X): syntax error pr\u00f3ximo de '...'\n</code></pre> <p>Al\u00e9m disso, erros sem\u00e2nticos como uso de vari\u00e1vel n\u00e3o declarada tamb\u00e9m s\u00e3o reportados.</p>"},{"location":"Desenvolvimento/parser/#5-execucao","title":"5. Execu\u00e7\u00e3o","text":"<p>Ao executar a an\u00e1lise l\u00e9xica, h\u00e1 dois resultados poss\u00edveis:</p>"},{"location":"Desenvolvimento/parser/#51-caso-a-analise-sintatica-seja-bem-sucedida","title":"5.1. Caso a an\u00e1lise sint\u00e1tica seja bem-sucedida","text":"<p>Quando a entrada est\u00e1 de acordo com as regras gramaticais, o parser imprime:</p> <pre><code>Parsing conclu\u00eddo com sucesso!\n</code></pre> <p>Essa mensagem indica que:</p> <ul> <li>todos os tokens foram consumidos corretamente;</li> <li>n\u00e3o houve viola\u00e7\u00e3o de nenhuma regra da gram\u00e1tica;</li> <li>a estrutura do programa \u00e9 sintaticamente v\u00e1lida.</li> </ul> <p>Nenhum detalhe adicional \u00e9 mostrado pelo parser nessa etapa, apenas a confirma\u00e7\u00e3o de sucesso.</p>"},{"location":"Desenvolvimento/parser/#52-caso-a-analise-sintatica-encontre-erro","title":"5.2. Caso a an\u00e1lise sint\u00e1tica encontre erro","text":"<p>Quando ocorre qualquer inconsist\u00eancia gramatical, o parser interrompe a an\u00e1lise e apresenta uma mensagem de erro como:</p> <pre><code>ERRO SINT\u00c1TICO (linha X): syntax error, unexpected TOKEN_X, expecting Y\nParsing interrompido por erro sint\u00e1tico.\n</code></pre> <p>Essa apresenta\u00e7\u00e3o sempre inclui:</p> <ul> <li>a linha onde o erro foi detectado,</li> <li>o token inesperado que causou a falha,</li> <li>o que era esperado naquele ponto,</li> <li>e a mensagem final informando a interrup\u00e7\u00e3o da an\u00e1lise.</li> </ul>"},{"location":"Desenvolvimento/parser/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Vers\u00e3o Descri\u00e7\u00e3o Autor Data Revisor 1.0 Cria\u00e7\u00e3o da v1 da documenta\u00e7\u00e3o do parser Ludmila Nunes 01/10/2025 Isaque Camargos 2.0 Cria\u00e7\u00e3o da vers\u00e3o final da documenta\u00e7\u00e3o do parser Ludmila Nunes 26/11/2025 Isaque Camargos"},{"location":"Desenvolvimento/st/","title":"ST - Symbol Table (Tabela de S\u00edmbolos)","text":""},{"location":"Desenvolvimento/st/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>A Tabela de S\u00edmbolos (Symbol Table - ST) \u00e9 uma das estruturas fundamentais do compilador, respons\u00e1vel por registrar e gerenciar informa\u00e7\u00f5es sobre identificadores durante a an\u00e1lise sem\u00e2ntica. Toda vari\u00e1vel, fun\u00e7\u00e3o ou vetor declarado no c\u00f3digo-fonte deve ser armazenado na ST, para permitir verifica\u00e7\u00f5es como: uso antes da declara\u00e7\u00e3o, tipos incompat\u00edveis, escopo v\u00e1lido e inicializa\u00e7\u00e3o.</p> <p>Na linguagem do projeto, a ST tamb\u00e9m oferece suporte a vetores, aos tipos b\u00e1sicos e ao controle expl\u00edcito de escopos, permitindo uma an\u00e1lise sem\u00e2ntica mais completa e segura.</p>"},{"location":"Desenvolvimento/st/#2-metodologia","title":"2. Metodologia","text":"<p>A implementa\u00e7\u00e3o da Tabela de S\u00edmbolos (ST) foi iniciada assim que o parser alcan\u00e7ou uma estrutura b\u00e1sica est\u00e1vel, permitindo reconhecer declara\u00e7\u00f5es, blocos e in\u00edcio de escopos. Com essa funda\u00e7\u00e3o, tornou-se poss\u00edvel integrar a ST ao processo de an\u00e1lise sint\u00e1tica para registrar identificadores conforme apareciam no c\u00f3digo-fonte.</p> <p>A metodologia adotada seguiu os seguintes princ\u00edpios:</p> <ul> <li>Uso de uma tabela hash est\u00e1tica, de tamanho fixo (<code>TAM = 227</code>), escolhida para minimizar colis\u00f5es sem exigir realoca\u00e7\u00e3o din\u00e2mica.</li> <li>Tratamento de colis\u00f5es via encadeamento externo, mantendo listas ligadas em cada posi\u00e7\u00e3o da tabela.</li> <li>Gerenciamento expl\u00edcito de escopos, atrav\u00e9s do contador escopo_atual, permitindo diferenciar s\u00edmbolos declarados em blocos distintos.</li> <li> <p>Estrutura de n\u00f3 de s\u00edmbolo bem definida, contendo:</p> <ul> <li>nome do identificador,</li> <li>tipo,</li> <li>escopo onde foi declarado,</li> <li>valor (quando inicializado),</li> <li>informa\u00e7\u00f5es extras para vetores,</li> <li>ponteiro para o pr\u00f3ximo s\u00edmbolo da lista no caso de colis\u00e3o.</li> </ul> </li> </ul> <p>Essa abordagem permitiu ao grupo evoluir gradualmente o compilador: primeiro garantindo uma an\u00e1lise sint\u00e1tica est\u00e1vel, e em seguida adicionando a l\u00f3gica de armazenamento e controle de identificadores de forma consistente com os escopos definidos pela linguagem.</p>"},{"location":"Desenvolvimento/st/#3-papel-da-st-no-compilador","title":"3. Papel da ST no Compilador","text":"<p>A ST \u00e9 utilizada durante:</p> <ul> <li>declara\u00e7\u00e3o de vari\u00e1veis: \u00e9 realizada inser\u00e7\u00e3o na tabela;</li> <li>uso de vari\u00e1veis: \u00e9 feita busca para validar exist\u00eancia e tipo;</li> <li>atribui\u00e7\u00f5es: h\u00e1 verifica\u00e7\u00e3o de inicializa\u00e7\u00e3o e compatibilidade de tipos;</li> <li>controle de escopos: entrada e sa\u00edda de blocos com remo\u00e7\u00e3o autom\u00e1tica dos s\u00edmbolos daquele n\u00edvel;</li> <li>opera\u00e7\u00f5es com vetores: verifica\u00e7\u00e3o de exist\u00eancia e acesso seguro.</li> </ul> <p>Assim, ela atua como o n\u00facleo da an\u00e1lise sem\u00e2ntica, garantindo que o programa seja consistente e evitando que o compilador aceite opera\u00e7\u00f5es inv\u00e1lidas.</p>"},{"location":"Desenvolvimento/st/#4-implementacao","title":"4. Implementa\u00e7\u00e3o","text":"<p>A implementa\u00e7\u00e3o est\u00e1 concentrada nos seguintes componentes:</p>"},{"location":"Desenvolvimento/st/#41-estrutura-de-hash","title":"4.1 Estrutura de Hash","text":"<p>A fun\u00e7\u00e3o <code>hash()</code> mapeia strings para \u00edndices dentro de <code>TAM</code>, utilizando uma combina\u00e7\u00e3o simples mas eficiente (<code>h * 32 + caractere</code>).</p>"},{"location":"Desenvolvimento/st/#42-insercao","title":"4.2 Inser\u00e7\u00e3o","text":"<p>A fun\u00e7\u00e3o <code>insertST()</code>:</p> <ul> <li>cria um novo s\u00edmbolo,</li> <li>inicializa seu valor padr\u00e3o,</li> <li>atribui o escopo atual,</li> <li>o insere no in\u00edcio da lista ligada do bucket correspondente.</li> </ul>"},{"location":"Desenvolvimento/st/#43-busca","title":"4.3 Busca","text":"<p>A fun\u00e7\u00e3o <code>searchST()</code> percorre a lista do bucket associado ao hash do nome, retornando o s\u00edmbolo encontrado.</p>"},{"location":"Desenvolvimento/st/#44-controle-de-escopo","title":"4.4 Controle de Escopo","text":"<ul> <li><code>openScope()</code> incrementa o escopo e inicia um novo n\u00edvel.</li> <li><code>closeScope()</code> remove todos os s\u00edmbolos pertencentes ao escopo atual.</li> <li><code>getScope()</code> retorna o n\u00edvel atual.</li> </ul> <p>Essa estrat\u00e9gia garante que vari\u00e1veis locais desapare\u00e7am ao final de blocos.</p>"},{"location":"Desenvolvimento/st/#45-impressao","title":"4.5 Impress\u00e3o","text":"<p><code>showST()</code> exibe:</p> <ul> <li>nome,</li> <li>tipo,</li> <li>escopo,</li> <li>se foi inicializada,</li> <li>valor atual ou elementos do vetor.</li> </ul>"},{"location":"Desenvolvimento/st/#46-liberacao-de-memoria","title":"4.6 Libera\u00e7\u00e3o de Mem\u00f3ria","text":"<p><code>freeST()</code> percorre toda a tabela e libera:</p> <ul> <li>vetores alocados,</li> <li>strings,</li> <li>n\u00f3s de s\u00edmbolos.</li> </ul>"},{"location":"Desenvolvimento/st/#5-execucao","title":"5. Execu\u00e7\u00e3o","text":"<p>Durante a execu\u00e7\u00e3o do compilador, o comportamento da Tabela de S\u00edmbolos se apresenta da seguinte forma:</p>"},{"location":"Desenvolvimento/st/#51-quando-o-programa-contem-declaracoes-validas","title":"5.1. Quando o programa cont\u00e9m declara\u00e7\u00f5es v\u00e1lidas","text":"<p>Os s\u00edmbolos s\u00e3o registrados com sucesso, e a tabela pode ser exibida ao final com <code>showST()</code>, apresentando:</p> <ul> <li>tipos,</li> <li>escopos,</li> <li>estado de inicializa\u00e7\u00e3o,</li> <li>valores atribu\u00eddos.</li> </ul> <p>Exemplo t\u00edpico de entrada v\u00e1lida:</p> <pre><code>===== TABELA DE S\u00cdMBOLOS =====\nNome: soma       | Tipo: INT     | Escopo: 0 | Inicializado: SIM | Valor: 3\nNome: c          | Tipo: BOOL    | Escopo: 0 | Inicializado: SIM | Valor: FALSE\nNome: d          | Tipo: STRING  | Escopo: 0 | Inicializado: SIM | Valor: \"ola mundo\"\nNome: f          | Tipo: FLOAT   | Escopo: 0 | Inicializado: SIM | Valor: 3.140000\nNome: vetor_int  | Tipo: VETOR   | Escopo: 0 | Inicializado: SIM | Valor: [0, 2, 3, 4]\n===============================\n</code></pre>"},{"location":"Desenvolvimento/st/#52-quando-ocorre-erro-semantico-envolvendo-simbolos","title":"5.2. Quando ocorre erro sem\u00e2ntico envolvendo s\u00edmbolos","text":"<p>A ST fornece mensagens como:</p> <ul> <li>uso de vari\u00e1vel n\u00e3o existente,</li> <li>acesso a vetor n\u00e3o inicializado,</li> <li>consulta a identificador inexistente.</li> </ul> <p>Exemplos:</p> <pre><code>Erro: vetor 'a' n\u00e3o existe na tabela de s\u00edmbolos.\nErro: vetor 'x' n\u00e3o foi inicializado.\n</code></pre>"},{"location":"Desenvolvimento/st/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Vers\u00e3o Descri\u00e7\u00e3o Autor Data Revisor 1.0 Cria\u00e7\u00e3o da v1 da documenta\u00e7\u00e3o da st Ludmila Nunes 26/11/2025"},{"location":"Desenvolvimento/tac/","title":"TAC - Three Adress Code (C\u00f3digo de Tr\u00eas Endere\u00e7os)","text":""},{"location":"Desenvolvimento/tac/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>O C\u00f3digo de Tr\u00eas Endere\u00e7os (TAC - Three-Address Code) \u00e9 uma forma de c\u00f3digo intermedi\u00e1rio fundamental no processo de compila\u00e7\u00e3o.</p> <p>O TAC tem como objetivo traduzir as constru\u00e7\u00f5es de alto n\u00edvel da linguagem de programa\u00e7\u00e3o, conforme reconhecidas e validadas pelo analisador sint\u00e1tico (parser), em uma sequ\u00eancia de instru\u00e7\u00f5es mais simples e primitivas.</p> <p>Cada instru\u00e7\u00e3o do TAC, como o nome sugere, tipicamente envolve no m\u00e1ximo tr\u00eas endere\u00e7os (refer\u00eancias a vari\u00e1veis, constantes ou valores tempor\u00e1rios), tornando-o uma representa\u00e7\u00e3o linear, expl\u00edcita e f\u00e1cil de manipular, servindo como uma ponte essencial entre a an\u00e1lise sint\u00e1tica e a gera\u00e7\u00e3o final do c\u00f3digo de m\u00e1quina.</p>"},{"location":"Desenvolvimento/tac/#2-metodologia","title":"2. Metodologia","text":"<p>A gera\u00e7\u00e3o do C\u00f3digo de Tr\u00eas Endere\u00e7os (TAC) \u00e9 implementada como uma fase de tradu\u00e7\u00e3o que se segue diretamente \u00e0 An\u00e1lise Sem\u00e2ntica, utilizando a \u00c1rvore de Sintaxe Abstrata (AST) como representa\u00e7\u00e3o de entrada. </p> <p>O gerador de TAC percorre a AST de forma recursiva, emitindo uma sequ\u00eancia linear de instru\u00e7\u00f5es que desconstroem as express\u00f5es complexas e as estruturas de controle em formas elementares de no m\u00e1ximo tr\u00eas operandos.</p> <p>O cora\u00e7\u00e3o da metodologia reside na fun\u00e7\u00e3o est\u00e1tica recursiva <code>static char* processar_no(NoAST* no)</code>.</p> <ul> <li>Express\u00f5es: Para n\u00f3s que representam express\u00f5es (<code>NO_OP_BINARIA</code>, <code>NO_ID</code>, <code>NO_NUM</code>), a fun\u00e7\u00e3o retorna uma string alocada (nome) que cont\u00e9m o endere\u00e7o do resultado da express\u00e3o (ex: o nome de uma vari\u00e1vel tempor\u00e1ria como <code>\"t1\"</code>, o nome de uma vari\u00e1vel como <code>\"x\"</code>, ou uma constante como <code>\"5\"</code>).</li> <li>Comandos: Para n\u00f3s que representam comandos ou estruturas de controle (<code>NO_ATRIBUICAO</code>, <code>NO_IF</code>, <code>NO_WHILE</code>), a fun\u00e7\u00e3o retorna <code>NULL</code>, pois seu objetivo \u00e9 apenas emitir as instru\u00e7\u00f5es TAC correspondentes.</li> </ul> <p>Para garantir que o c\u00f3digo TAC mantenha sua forma expl\u00edcita de tr\u00eas endere\u00e7os, s\u00e3o utilizadas fun\u00e7\u00f5es auxiliares que geram identificadores \u00fanicos:</p> Fun\u00e7\u00e3o Finalidade Exemplo <code>static char* novo_temp()</code> Cria vari\u00e1veis tempor\u00e1rias para armazenar resultados de sub-express\u00f5es. <code>t0</code>, <code>t1</code>, <code>t2</code> <code>static char* novo_label()</code> Cria r\u00f3tulos para controle de fluxo. <code>L0</code>, <code>L1</code>, <code>L_INICIO</code>"},{"location":"Desenvolvimento/tac/#3-papel-do-tac-no-compilador","title":"3. Papel do TAC no Compilador","text":"<p>O C\u00f3digo de Tr\u00eas Endere\u00e7os (TAC) estabelece-se como uma fase de c\u00f3digo intermedi\u00e1rio no pipeline do compilador, servindo como uma abstra\u00e7\u00e3o essencial que isola as etapas de  an\u00e1lise da linguagem das etapas de otimiza\u00e7\u00e3o e gera\u00e7\u00e3o do c\u00f3digo final.</p>"},{"location":"Desenvolvimento/tac/#4-implementacao","title":"4. Implementa\u00e7\u00e3o","text":""},{"location":"Desenvolvimento/tac/#41-codigo","title":"4.1. C\u00f3digo","text":"<p>A implementa\u00e7\u00e3o do gerador de C\u00f3digo de Tr\u00eas Endere\u00e7os (TAC) est\u00e1 contida no arquivo <code>tac.c</code> e \u00e9 baseada em uma abordagem de tradu\u00e7\u00e3o orientada por sintaxe, onde cada n\u00f3 da \u00c1rvore de Sintaxe Abstrata (AST) \u00e9 mapeado para uma ou mais instru\u00e7\u00f5es de c\u00f3digo intermedi\u00e1rio.</p>"},{"location":"Desenvolvimento/tac/#estruturas-principais-tach","title":"Estruturas Principais (<code>tac.h</code>)","text":"<p>As defini\u00e7\u00f5es essenciais para o TAC est\u00e3o no cabe\u00e7alho <code>tac.h</code>:</p> <ol> <li><code>TacOpcode</code> (Enumera\u00e7\u00e3o): Define o conjunto de opera\u00e7\u00f5es at\u00f4micas suportadas pelo c\u00f3digo intermedi\u00e1rio (ex: <code>TAC_SOMA</code>, <code>TAC_GOTO</code>, <code>TAC_CHAMADA</code>, <code>TAC_VET_SET</code>).</li> <li><code>TacInstrucao</code> (Struct): Representa uma instru\u00e7\u00e3o individual, contendo o <code>op</code> (opcode) e as tr\u00eas strings de endere\u00e7o (<code>res</code>, <code>arg1</code>, <code>arg2</code>). A lista \u00e9 constru\u00edda por meio do ponteiro <code>proxima</code>.</li> <li><code>TacCodigo</code> (Struct): Serve como o cont\u00eainer principal para o c\u00f3digo gerado, mantendo ponteiros para o <code>inicio</code> e o <code>fim</code> da lista de instru\u00e7\u00f5es, facilitando a adi\u00e7\u00e3o (append) no tempo constante O(1).</li> </ol>"},{"location":"Desenvolvimento/tac/#funcoes-de-gerenciamento","title":"Fun\u00e7\u00f5es de Gerenciamento","text":"<p>O arquivo <code>tac.c</code> utiliza vari\u00e1veis est\u00e1ticas para manter o estado da gera\u00e7\u00e3o de c\u00f3digo e fun\u00e7\u00f5es auxiliares para manipular endere\u00e7os:</p> <ul> <li><code>static int contador_temp</code> e <code>static int contador_label</code>: Contadores utilizados pelas fun\u00e7\u00f5es <code>novo_temp()</code> e <code>novo_label()</code> para garantir a unicidade dos identificadores gerados (ex: <code>t0</code>, <code>t1</code>, <code>L0</code>, <code>L1</code>).</li> <li><code>static void emitir(TacOpcode op, char* res, char* arg1, char* arg2)</code>: Fun\u00e7\u00e3o crucial que aloca uma nova estrutura <code>TacInstrucao</code>, copia as strings de endere\u00e7o fornecidas, e adiciona a nova instru\u00e7\u00e3o ao final da lista global.</li> </ul>"},{"location":"Desenvolvimento/tac/#o-mecanismo-de-traducao","title":"O Mecanismo de Tradu\u00e7\u00e3o","text":"<p>A tradu\u00e7\u00e3o \u00e9 realizada por meio de uma \u00fanica fun\u00e7\u00e3o recursiva, que processa a AST em ordem p\u00f3s-fixada (depth-first traversal):</p> <ul> <li><code>static char* processar_no(NoAST* no)</code>: Esta fun\u00e7\u00e3o implementa a l\u00f3gica de tradu\u00e7\u00e3o para cada tipo de n\u00f3 da AST.<ul> <li>Express\u00f5es: Obt\u00e9m os endere\u00e7os dos argumentos (<code>esq</code>, <code>dir</code>), aloca um novo tempor\u00e1rio (<code>res = novo_temp()</code>), emite a instru\u00e7\u00e3o TAC correspondente (ex: <code>t0 = a + b</code>), e retorna o nome desse tempor\u00e1rio (<code>res</code>) para o n\u00f3 pai.</li> <li>Comandos: Emite as instru\u00e7\u00f5es de controle de fluxo (ex: <code>TAC_IFZ</code>, <code>TAC_GOTO</code>, <code>TAC_LABEL</code>) e retorna <code>NULL</code>, j\u00e1 que comandos n\u00e3o produzem um valor.</li> </ul> </li> </ul> <p>A manipula\u00e7\u00e3o de estruturas como operadores l\u00f3gicos (AND/OR) e loops (<code>while</code>, <code>for</code>) exige a emiss\u00e3o de sequ\u00eancias de instru\u00e7\u00f5es, utilizando os r\u00f3tulos gerados por <code>novo_label()</code> para implementar a l\u00f3gica de short-circuit e a repeti\u00e7\u00e3o controlada.</p>"},{"location":"Desenvolvimento/tac/#5-execucao","title":"5. Execu\u00e7\u00e3o","text":""},{"location":"Desenvolvimento/tac/#51-codigo-fonte","title":"5.1. C\u00f3digo Fonte","text":"<p>O c\u00f3digo de teste utilizado (<code>ok_03_chamadaFuncao.py</code>) define duas vari\u00e1veis e duas fun\u00e7\u00f5es de soma, chamando a primeira fun\u00e7\u00e3o com vari\u00e1veis e a segunda com constantes:</p> <pre><code>a = 2\nb = 2\n\ndef soma(a, b):\n    return a + b\n\nprint(soma(a, b))\n\ndef soma2(c, d):\n    return c + d\n\nprint(soma(1, 2))\n\n</code></pre> <p>TAC gerado na execu\u00e7\u00e3o desse caso de teste:</p> <p></p>"},{"location":"Desenvolvimento/tac/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Vers\u00e3o Descri\u00e7\u00e3o Autor Data Revisor 1.0 Cria\u00e7\u00e3o do Documento Rafael Schadt 26/11/2025 Ludmila Nunes"},{"location":"Dificuldades/dificuldades/","title":"Dificuldades","text":"<p>No in\u00edcio, foi desafiador transformar conceitos t\u00e3o abstratos em passos concretos e compreender a linguagem tanto sint\u00e1tica quanto lexicalmente. O lexer trouxe menos desafios, embora ele tenha sido refeito diversas vezes ao trabalhar no parser, principalmente para estruturar a gram\u00e1tica e entender como as regras se conectam. O parser foi feito do zero no m\u00ednimo 5 vezes, foi extremamente desafiador fazer com que nada tivesse conflito. Apesar de o compilador estar completo, ele ainda assombrar\u00e1 nossas vidas ao olhar para uma TAC.</p>"},{"location":"Dificuldades/dificuldades/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Vers\u00e3o Descri\u00e7\u00e3o Autor Data Revisor 1.0 Cria\u00e7\u00e3o do documento Isaque Camargos 01/09/2025 Ludmila Nunes 1.1 Atualiza\u00e7\u00e3o do documento Isaque Camargos 26/11/2025 Ludmila Nunes"},{"location":"Escopo/escopo/","title":"Escopo Geral do Compilador","text":"<p>O desenvolvimento do compilador contemplou um conjunto de funcionalidades essenciais para garantir a tradu\u00e7\u00e3o correta de programas escritos em Python para sua correspondente implementa\u00e7\u00e3o em linguagem C. O escopo atingido reflete tanto os requisitos m\u00ednimos para a execu\u00e7\u00e3o de programas b\u00e1sicos quanto a viabilidade t\u00e9cnica dentro do prazo estabelecido.</p> <p>Abaixo, est\u00e3o descritos os elementos implementados, suas respectivas capacidades junto a amostras de casos de testes:</p>"},{"location":"Escopo/escopo/#atribuicoes","title":"Atribui\u00e7\u00f5es","text":"<p>Implementado suporte para declara\u00e7\u00f5es e atribui\u00e7\u00f5es de vari\u00e1veis dos tipos primitivos mais comuns da linguagem Python, incluindo:</p> <p>int, float, string, booleanos (True, False) e none. Durante o processo de compila\u00e7\u00e3o, cada tipo \u00e9 convertido para o tipo C equivalente, garantindo compatibilidade sem\u00e2ntica. Al\u00e9m disso o compilador tem suporte para vetor de inteiros.</p> C\u00f3digo Python testado que contempla esse escopo /src/tests/inputs/sintatico/ok_01_declaracao.py   <pre><code>a =1\nb= 2\nc = True\nd = \"ola mundo\"\nf = 1.4\nvetor_int = [1,2,3,4]\nsoma = a + b\nif a &lt; b:\n    f = 3.14\n    c = False\n    vetor_int[0] = 0\n</code></pre> C\u00f3digo C gerado que contempla o caso de teste acima /src/tests/outputs/sintatico/ok_01_declaracao.c   <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n /* Declara\u00e7\u00f5es de vari\u00e1veis globais */\n int soma = 3;\n int a = 1;\n int b = 2;\n int c = 0;\n char* d = \"ola mundo\";\n float f = 3.140000;\n int vetor_int[4];\n\n\nint main() {\n vetor_int[0] = 0;\n vetor_int[1] = 2;\n vetor_int[2] = 3;\n vetor_int[3] = 4;\n a = 1;\n b = 2;\n c = 1;\n d = \"ola mundo\";\n f = 1.400000;\n soma = (a + b);\n if ((a &lt; b)) {\n  f = 3.140000;\n  c = 0;\n  vetor_int[0] = 0;\n }\n    return 0;\n}\n</code></pre>"},{"location":"Escopo/escopo/#operadores-aritmeticos","title":"Operadores Aritm\u00e9ticos","text":"<p>Suporte completo aos operadores: +, -, *, /.</p> C\u00f3digo Python testado que contempla esse escopo /src/tests/inputs/sintatico/ok_02_expressoesMat.py  <pre><code>b = 1\nc = 1\na = (6+2)/2*4\nd = a+(b +c)*2\ne = 2/2\n</code></pre> C\u00f3digo C gerado que contempla o caso de teste acima /src/tests/outputs/sintatico/ok_02_expressoesMat.c   <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n /* Declara\u00e7\u00f5es de vari\u00e1veis globais */\n int a = 16;\n int b = 1;\n int c = 1;\n int d = 20;\n int e = 1;\n\n\nint main() {\n b = 1;\n c = 1;\n a = (((6 + 2) / 2) * 4);\n d = (a + ((b + c) * 2));\n e = (2 / 2);\n    return 0;\n}\n</code></pre>"},{"location":"Escopo/escopo/#expressoes-matematicas","title":"Express\u00f5es Matem\u00e1ticas","text":"<p>Express\u00f5es num\u00e9ricas envolvendo opera\u00e7\u00f5es combinadas e preced\u00eancia de operadores s\u00e3o reconhecidas e corretamente traduzidas. Garantiu-se an\u00e1lise sint\u00e1tica adequada para express\u00f5es simples e compostas.</p> C\u00f3digo Python testado que contempla esse escopo /src/tests/inputs/sintatico/ok_02_expressoesMat.py  <pre><code>b = 1\nc = 1\na = (6+2)/2*4\nd = a+(b +c)*2\ne = 2/2\n</code></pre> C\u00f3digo C gerado que contempla o caso de teste acima /src/tests/outputs/sintatico/ok_02_expressoesMat.c   <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n /* Declara\u00e7\u00f5es de vari\u00e1veis globais */\n int a = 16;\n int b = 1;\n int c = 1;\n int d = 20;\n int e = 1;\n\n\nint main() {\n b = 1;\n c = 1;\n a = (((6 + 2) / 2) * 4);\n d = (a + ((b + c) * 2));\n e = (2 / 2);\n    return 0;\n}\n</code></pre>"},{"location":"Escopo/escopo/#estruturas-condicionais","title":"Estruturas Condicionais","text":"<p>Implementa\u00e7\u00e3o de condicionais aninhadas utilizando if e else. Embora a linguagem Python disponha de elif, essa constru\u00e7\u00e3o foi propositalmente omitida. Casos que envolvem m\u00faltiplas condi\u00e7\u00f5es s\u00e3o tratados por encadeamento aninhado de else-if.</p> C\u00f3digo Python testado que contempla esse escopo /src/tests/inputs/sintatico/ok_06_decisaoIf.py   <pre><code>def testar_condicionais(a, b, c):\n    if a == b:\n        print(\"a \u00e9 igual a b (==)\")\n    else:\n        if a != b and b &lt; c:\n            print(\"a \u00e9 diferente de b (!=) E b \u00e9 menor que c (&lt;)\")\n        else:\n            if a &gt; b or c &lt;= b:\n                print(\"a \u00e9 maior que b (&gt;) OU c \u00e9 menor ou igual a b (&lt;=)\")\n            else:\n                print(\"Nenhuma condi\u00e7\u00e3o anterior satisfeita\")\n\n\n\ntestar_condicionais(5, 3, 10)\n</code></pre> C\u00f3digo C gerado que contempla o caso de teste acima /src/tests/outputs/sintatico/ok_06_decisaoIf.c    <pre><code>\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n /* Declara\u00e7\u00f5es de vari\u00e1veis globais */\n\n\nint testar_condicionais(int a, int b, int c) {\n if ((a ! 0)) {\n  printf(\"negado\");\n }\n if ((a == b)) {\n  printf(\"a \u00e9 igual a b (==)\");\n } else {\n  if (((a != b) &amp;&amp; (b &lt; c))) {\n   printf(\"a \u00e9 diferente de b (!=) E b \u00e9 menor que c (&lt;)\");\n  } else {\n   if (((a &gt; b) || (c &lt;= b))) {\n    printf(\"a \u00e9 maior que b (&gt;) OU c \u00e9 menor ou igual a b (&lt;=)\");\n   } else {\n    printf(\"Nenhuma condi\u00e7\u00e3o anterior satisfeita\");\n   }\n   testar_condicionais(5, 3, 10);\n  }\n }\n}\n\nint main() {\n    return 0;\n}\n\n</code></pre>"},{"location":"Escopo/escopo/#operadores-logicos","title":"Operadores L\u00f3gicos","text":"<p>O compilador reconhece e traduz corretamente operadores l\u00f3gicos e relacionais, como: and, or, &gt;, &gt;=, &lt;, &lt;=, !=.</p> C\u00f3digo Python testado que contempla esse escopo /src/tests/inputs/sintatico/ok_06_decisaoIf.py   <pre><code>def testar_condicionais(a, b, c):\n    if a == b:\n        print(\"a \u00e9 igual a b (==)\")\n    else:\n        if a != b and b &lt; c:\n            print(\"a \u00e9 diferente de b (!=) E b \u00e9 menor que c (&lt;)\")\n        else:\n            if a &gt; b or c &lt;= b:\n                print(\"a \u00e9 maior que b (&gt;) OU c \u00e9 menor ou igual a b (&lt;=)\")\n            else:\n                print(\"Nenhuma condi\u00e7\u00e3o anterior satisfeita\")\n\n\n\ntestar_condicionais(5, 3, 10)\n</code></pre> C\u00f3digo C gerado que contempla o caso de teste acima /src/tests/outputs/sintatico/ok_06_decisaoIf.c    <pre><code>\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n /* Declara\u00e7\u00f5es de vari\u00e1veis globais */\n\n\nint testar_condicionais(int a, int b, int c) {\n if ((a ! 0)) {\n  printf(\"negado\");\n }\n if ((a == b)) {\n  printf(\"a \u00e9 igual a b (==)\");\n } else {\n  if (((a != b) &amp;&amp; (b &lt; c))) {\n   printf(\"a \u00e9 diferente de b (!=) E b \u00e9 menor que c (&lt;)\");\n  } else {\n   if (((a &gt; b) || (c &lt;= b))) {\n    printf(\"a \u00e9 maior que b (&gt;) OU c \u00e9 menor ou igual a b (&lt;=)\");\n   } else {\n    printf(\"Nenhuma condi\u00e7\u00e3o anterior satisfeita\");\n   }\n   testar_condicionais(5, 3, 10);\n  }\n }\n}\n\nint main() {\n    return 0;\n}\n\n</code></pre>"},{"location":"Escopo/escopo/#lacos-de-repeticao","title":"La\u00e7os de Repeti\u00e7\u00e3o","text":"<p>Implementa\u00e7\u00e3o dos dois principais la\u00e7os utilizados no recorte do projeto:</p>"},{"location":"Escopo/escopo/#while","title":"while","text":"C\u00f3digo Python testado que contempla esse escopo /src/tests/inputs/sintatico/ok_04_lacosWhile.py   <pre><code>i =0\nwhile i &lt;10:\n    print(i)\n    i=i+1\n</code></pre> C\u00f3digo C gerado que contempla o caso de teste acima /src/tests/outputs/sintatico/ok_04_lacosWhile.c   <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n /* Declara\u00e7\u00f5es de vari\u00e1veis globais */\n int i = 0;\n\n\nint main() {\n i = 0;\n while ((i &lt; 10)) {\n  printf(\"%d\", i);\n  i = (i + 1);\n }\n    return 0;\n}\n</code></pre>"},{"location":"Escopo/escopo/#for-i-in-rangen-com-suporte-para-range-simples","title":"for i in range(n) (com suporte para range simples)","text":"<p>Ambos s\u00e3o traduzidos para estruturas de repeti\u00e7\u00e3o equivalentes em C, mantendo controle de fluxo e vari\u00e1veis de itera\u00e7\u00e3o.</p> C\u00f3digo Python testado que contempla esse escopo /src/tests/outputs/sintatico/ok_05_for.py   <pre><code>for i in range(0,5):\n    print(f\"i: {i}\")\n</code></pre> C\u00f3digo C gerado que contempla o caso de teste acima /src/tests/outputs/sintatico/ok_05_for.c   <pre><code>\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n /* Declara\u00e7\u00f5es de vari\u00e1veis globais */\n\n\nint main() {\n for (int __i = 0; __i &lt; 5; __i++) {\n  i = __i;\n  printf(\"%d\", i);\n }\n    return 0;\n}\n\n</code></pre>"},{"location":"Escopo/escopo/#funcoes-chamadas-e-retornos","title":"Fun\u00e7\u00f5es, Chamadas e Retornos","text":"<p>O compilador suporta a declara\u00e7\u00e3o e utiliza\u00e7\u00e3o de fun\u00e7\u00f5es com retorno void e int. H\u00e1 suporte para, par\u00e2metros, chamadas a fun\u00e7\u00f5es, retorno de valores.</p> <p>escopo local de vari\u00e1veis. As fun\u00e7\u00f5es em Python s\u00e3o mapeadas diretamente para fun\u00e7\u00f5es em C, conforme os tipos permitidos.</p> C\u00f3digo Python testado que contempla esse escopo /src/tests/inputs/sintatico/ok_03_chamadaFuncao.py   <pre><code>a = 2\nb = 2\ndef soma(a ,b):\n    return a+b\nprint(soma(a,b))\n\ndef soma2(c ,d):\n    print(c+d)\n</code></pre> C\u00f3digo C gerado que contempla o caso de teste acima /src/tests/outputs/sintatico/ok_03_chamadaFuncao.c   <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n /* Declara\u00e7\u00f5es de vari\u00e1veis globais */\n int a = 2;\n int b = 2;\n\n\nint soma(int a, int b) {\n return (a + b);\n}\n\nint soma2(int c, int d) {\n printf(\"%d\", (c + d));\n}\n\nint main() {\n a = 2;\n b = 2;\n printf(\"%d\", soma(a, b));\n    return 0;\n}\n</code></pre>"},{"location":"Escopo/escopo/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"<p> Tabela 1: Hist\u00f3rico de vers\u00f5es </p> Vers\u00e3o Descri\u00e7\u00e3o Autor Data Revisor 1.0 Cria\u00e7\u00e3o do documento Laryssa Felix 01/10/2025 Caio Duarte 1.0 Adiciona documenta\u00e7\u00e3o Caio Duarte 26/11/2025 Laryssa Felix"},{"location":"Metodologia/metodologia/","title":"Metodologia","text":"<p>Para a organiza\u00e7\u00e3o do trabalho, a equipe adotou uma metodologia baseada em Kanban, com as tarefas divididas em colunas que representam seu status: \"A Fazer\", \"Em Andamento\" e \"Conclu\u00eddo\". Cada atividade possui uma data de entrega previamente definida, permitindo o acompanhamento do progresso, a prioriza\u00e7\u00e3o das tarefas e a identifica\u00e7\u00e3o de poss\u00edveis gargalos no desenvolvimento. Todas as decis\u00f5es t\u00e9cnicas e altera\u00e7\u00f5es importantes s\u00e3o registradas e documentadas no reposit\u00f3rio do GitHub.</p> <p> </p> <p>O projeto \u00e9 composto pelas seguintes atividades principais:</p> <p>1. Defini\u00e7\u00e3o da gram\u00e1tica e do escopo da linguagem Python suportada pelo compilador</p> <p>2. An\u00e1lise l\u00e9xica, respons\u00e1vel pelo reconhecimento de tokens, vari\u00e1veis, tipos, estruturas condicionais, la\u00e7os e mensagens de erro</p> <p>3. An\u00e1lise sint\u00e1tica (parser), respons\u00e1vel por interpretar a estrutura do c\u00f3digo, express\u00f5es matem\u00e1ticas, atribui\u00e7\u00e3o de vari\u00e1veis, chamadas de fun\u00e7\u00f5es, indenta\u00e7\u00e3o, condicionais, la\u00e7os, fun\u00e7\u00f5es e vetores de inteiros.</p> <p>4. An\u00e1lise sem\u00e2ntica e constru\u00e7\u00e3o da \u00e1rvore sint\u00e1tica abstrata (AST)</p> <p>5. Gera\u00e7\u00e3o de c\u00f3digo intermedi\u00e1rio com TAC</p> <p>6. Cria\u00e7\u00e3o do c\u00f3digo final para C</p> <p>7. Testes e valida\u00e7\u00e3o utilizando casos pr\u00e1ticos para garantir o correto funcionamento do compilador</p> <p>8. Documenta\u00e7\u00e3o cont\u00ednua, incluindo planejamento, justificativas t\u00e9cnicas, hist\u00f3rico de vers\u00f5es e registro de dificuldades encontradas</p> <p> </p>"},{"location":"Metodologia/metodologia/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"<p> Tabela 1: Hist\u00f3rico de vers\u00f5es </p> Vers\u00e3o Descri\u00e7\u00e3o Autor Data Revisor 1.0 Cria\u00e7\u00e3o do documento Laryssa Felix 01/10/2025 Caio Duarte <p> Fonte: Caio Duarte, Isaque Camargos, Laryssa Felix, Ludmila Aysha, Rafael Welz, 2025. </p>"},{"location":"Planejamento/planejamento/","title":"Planejamento","text":""}]}